package com.bignerdranch.android.currencyconverter.views

import androidx.databinding.BaseObservable
import androidx.databinding.Bindable
import com.bignerdranch.android.currencyconverter.models.Valute

//c data binding нужно использовать свой ViewModel (он будет расширять интерфейс baseObservable с.м. data binding)
// а не jetpack класс ViewModel!!! (или убирать jetpack класс ViewModel во View область)
//ЭТОТ КЛАСС И ЕСТЬ VIEW MODEL для databinding, а View тут является сгенерированный из xml RecycerViewItemBinding
//Тут получился локальный MVVM для одного элемента recyclerview


//Большая часть работы по форматированию данных, которая ранее выполнялась классами контроллеров, переходит к модели представления. Подключение виджетов к данным будет осуществляться непосредственно в файле макета с использованием привязки данных к модели представления. Контроллер (ваша activity или фрагмент) будет отвечать за такие операции, как инициализация привязки и модели представления и создание связи между ними.
class ValuteItemViewModel : //Эта модель представления отвечает за принятие решений относительно того, как должны отображаться данные.
//Прокручивая список вверх и вниз, вы увидите, что имена других файлов появляются в неожиданных, случайных на первый взгляд местах. Если вы этого не видите, поверните устройство в альбомный режим и попробуйте еще раз посмотреть, что к чему.
//Это происходит потому, что ваш макет не имеет возможности узнать, что вы обновили объект Valute, принадлежащий ValuteItemViewModel, внутри функции SoundHolder.bind(Sound). Другими словами, модель представления неправильно переносит данные в ваш макетный файл.
//Помимо четкого разделения обязанностей, этот момент — тот самый секретный ингредиент, который отличает MVVM от других архитектур, таких как MVC.
//
//Необходимо добавить эту связь. Для этого ваша модель представления должна реализовать интерфейс Observable привязки данных. Этот интерфейс позволяет классу привязки установить слушателей для модели представления, чтобы он мог автоматически получать обратные вызовы при изменении полей.
    BaseObservable() {

    var valute: Valute? = null
        set(valute){
            field = valute
            notifyChange()//Вызывайте notifyChange() или notifyPropertyChanged(int) при каждом изменении значения свойства привязки.
        //Когда вы вызываете функцию notifyChange(), она оповещает класс привязки о том, что все Bindable-свойства ваших объектов были обновлены. Класс привязки выполняет код внутри скобок {} в xml файле для повторного заполнения представления.
        //Таким образом, при установке значения valute объект RecycerViewItemBinding получит уведомление и вызовет TextView.setText(String), как указано в файле recycle_view_item.xml.
        //Используя запись notifyChange(), вы говорите: «Все Bindable-свойства изменились; всё нужно обновить». При использовании notifyPropertyChanged(BR.title) сообщается: «Изменилось только значение title».
        }

    @get: Bindable//Снабдите свойства, используемые в привязке, аннотацией @Bindable.
    val currencyName: String?//Эти свойства образуют интерфейс, который будет использоваться вашим адаптером. Файлу макета потребуется дополнительная функция для получения названия, которое должно отображаться
        get() = valute?.name
    @get: Bindable
    val currencyCode: String?
        get() = valute?.charCode
}
//BR.title — это константа, которая генерируется библиотекой привязки данных. Имя класса BR — это сокращение от binding resource — «связующий ресурс». Каждое свойство, которое вы аннотируете с помощью @Bindable, дает результат в сгенерированной константе BR с тем же именем
